#!/bin/bash

_is_in_git_repo() {
  git rev-parse HEAD > /dev/null 2>&1
}

fgt() {
  _is_in_git_repo || return 1

  local mode="modified"
  while getopts ":sum" opt; do
    case $opt in
      s) mode="staged" ;;
      u) mode="unstaged" ;;
      m) mode="modified" ;;
      *) mode="all" ;;
    esac
  done
  shift $((OPTIND - 1))

  local q="${*:-}"
  local cmd
  local preview='git diff --color=always -- {}'

  case "$mode" in
    staged)   cmd='git diff --name-only --cached -z' ;;
    unstaged) cmd='git diff --name-only -z' ;;
    modified) cmd='git diff --name-only -z; git diff --name-only --cached -z' ;;
    all)      cmd='git ls-files -z' ;;
  esac

  eval "$cmd" |
    tr '\0' '\n' |
    sort -u |
    fzf --query "$q" \
        --height=80% --layout=reverse --border \
        --preview "$preview"
}

fgt-widget() {
  local -a files
  local out

  out="$(fgt)" || { zle reset-prompt; return 0; }
  [[ -n "$out" ]] || { zle reset-prompt; return 0; }

  files=("${(@f)out}")
  LBUFFER+="${LBUFFER:+ }${(j: :)${(q)files}}"
  zle reset-prompt
}

if [[ -n "${ZSH_VERSION-}" ]]; then
  zle -N fgt-widget
  bindkey '^G' fgt-widget
fi

gsw() {
  _is_in_git_repo || return 1
  local branch
  branch=$(git branch -a -vv --color=always | grep -v '/HEAD\s' |
    fzf --height 40% --ansi --multi --tac \
        --preview "git log --oneline --graph --date=short --color=always --pretty='format:%C(auto)%cd %h%d %s' \$(sed 's/^..//' <<< {} | awk '{print \$1}' | sed 's#^remotes/[^/]*/##') --" \
        --preview-window right:50%) || return 0

  [ -n "$branch" ] || return 0
  branch=$(echo "$branch" | sed 's/^..//' | awk '{print $1}' | sed 's#^remotes/[^/]*/##')
  git switch $branch
}

fgst() {
  _is_in_git_repo || return 1
  local selection
  selection=$(git -c color.status=always status --short |
    fzf --height 40% -m --ansi --nth 2..,.. \
        --preview 'git diff --color=always {2}' \
        --preview-window right:60%) || return 0
  echo "$selection" | awk '{print $2}'
}

fgtg() {
  _is_in_git_repo || return 1
  git tag --sort -version:refname |
    fzf --height 40% --multi \
        --preview 'git show --color=always {} | head -50' \
        --preview-window right:60%
}

fgll() {
  _is_in_git_repo || return 1
  local selection
  selection=$(git log --date=short --format="%C(green)%C(bold)%cd %C(auto)%h%d %s (%an)" --graph |
    fzf --height 40% --ansi --no-sort --reverse --multi \
        --preview 'grep -o "[a-f0-9]\{7,\}" <<< {} | head -1 | xargs git show --color=always' \
        --preview-window right:60%) || return 0
  echo "$selection" | grep -o '[a-f0-9]\{7,\}'
}

fkill() {
  local pid
  if [ "$UID" != "0" ]; then
    pid=$(ps -f -u $UID | sed 1d | fzf -m --preview='' | awk '{print $2}')
  else
    pid=$(ps -ef | sed 1d | fzf -m --preview='' | awk '{print $2}')
  fi
  if [ "x$pid" != "x" ]; then
    echo $pid | xargs kill -${1:-9}
  fi
}

if [ -n "${ZSH_VERSION-}" ]; then
  zle -N fkill
  bindkey '^K' fkill
fi

fman() {
  man -k . | sort |
    sed -E 's/^([^[:space:]]+)\([^)]+\),?/\1/' |
    awk -v cyan="$(tput setaf 6)" -v blue="$(tput setaf 4)" \
        -v res="$(tput sgr0)" -v bld="$(tput bold)" \
        '{ $1=cyan bld $1; $2=res blue } 1' |
    fzf \
      -q "${1:-}" \
      --ansi \
      --tiebreak=begin \
      --prompt='ïš Man > ' \
      --preview-window '50%,rounded,<50(up,85%,border-bottom)' \
      --preview "tldr --color=always {1} 2>/dev/null" \
      --bind 'enter:become(man {1})'
}

fman-widget() {
  fman
  zle reset-prompt
}

if [[ -n ${ZSH_VERSION-} ]]; then
  zle -N fman-widget
  bindkey '^N' fman-widget
fi

spell() {
  local q="${*:-}"
  local w words_file clip_cmd

  if [[ -r /usr/share/dict/words ]]; then
    words_file=/usr/share/dict/words
  elif [[ -r /usr/dict/words ]]; then
    words_file=/usr/dict/words
  else
    echo "spell: no words file found (/usr/share/dict/words)" >&2
    return 1
  fi

  if command -v pbcopy >/dev/null 2>&1; then
    clip_cmd="pbcopy"
  elif command -v wl-copy >/dev/null 2>&1; then
    clip_cmd="wl-copy"
  elif command -v xclip >/dev/null 2>&1; then
    clip_cmd="xclip -selection clipboard"
  elif command -v xsel >/dev/null 2>&1; then
    clip_cmd="xsel --clipboard --input"
  else
    echo "spell: no clipboard tool found (pbcopy/wl-copy/xclip/xsel)" >&2
    return 1
  fi

  local preview=':'
  if command -v dict >/dev/null 2>&1; then
    preview='sh -c '"'"'dict -d wn "$1" 2>/dev/null | fold -w "${COLUMNS:-80}" -s'"'"' _ {}'
  else
    preview='sh -c '"'"'printf "%s\n" "$1"'"'"' _ {}'
  fi

  w="$(
    fzf --query "$q" \
        --height=80% --layout=default --preview-window=up:60% --border \
        --preview "$preview" \
        <"$words_file"
  )" || return
  [ -n "$w" ] || return
  printf '%s' "$w" | ${=clip_cmd}
}

rgi() {
  if [ ! "$#" -gt 0 ]; then
    echo "Need a string to search for!"
    return 1
  fi
  rg --files-with-matches --no-messages "$1" |
    fzf --preview "
      highlight -O ansi -l {} 2> /dev/null |
      rg --colors 'match:bg:yellow' \
         --ignore-case \
         --pretty \
         --context 10 '$1' \
      || rg --ignore-case \
            --pretty \
            --context 10 '$1' \
            {}"
}

vrg() {
  local file
  file="$(rgi "$@")" || return
  [ -n "$file" ] || return
  nvim -- "$file"
}

fcd() {
  local searchdir destdir
  searchdir="${1:-$HOME}"
  destdir=$(
    fd --type d \
       --hidden \
       --exclude .git \
       --exclude __pycache__ \
       . "$searchdir" | fzf
  )
  [ -z "$destdir" ] && return 1
  cd "$destdir" || exit
}

topmem() {
  ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem | head
}

delete-broken-symlinks() {
  find . -xtype l -print0 | xargs -0 -r rm -v --
}

y() {
  local tmp cwd
  tmp="$(mktemp -t "yazi-cwd.XXXXXX")"
  yazi "$@" --cwd-file="$tmp"
  if cwd="$(command cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
    cd -- "$cwd" || exit
  fi
  \rm -f -- "$tmp"
}

json-beautify-inplace() {
  local input="$1" tmp
  [ -n "$input" ] || {
    echo "usage: json-beautify-inplace <file>" >&2
    return 2
  }
  tmp="$(mktemp)" || return
  \cp -- "$input" "$tmp" || {
    \rm -f -- "$tmp"
    return 1
  }
  jq . -- "$tmp" >"${tmp}.out" && mv -- "${tmp}.out" "$input"
  local rc=$?
  \rm -f -- "$tmp" "${tmp}.out"
  return $rc
}

json-beautify-sort-inplace() {
  local input="$1" tmp
  [ -n "$input" ] || {
    echo "usage: json-beautify-sort-inplace <file>" >&2
    return 2
  }
  tmp="$(mktemp)" || return
  \cp -- "$input" "$tmp" || {
    \rm -f -- "$tmp"
    return 1
  }
  jq -S . -- "$tmp" >"${tmp}.out" && mv -- "${tmp}.out" "$input"
  local rc=$?
  \rm -f -- "$tmp" "${tmp}.out"
  return $rc
}

mkcd() {
  mkdir -p -- "$1" && cd -- "$1" || return
}

cdtemp() {
  local dir
  dir="$(mktemp -d)" || return
  chmod 0700 "$dir"
  cd -- "$dir" || return
  if [ $# -eq 1 ]; then
    mkdir -p -- "$1" && cd -- "$1" && chmod 0700 .
  fi
}
